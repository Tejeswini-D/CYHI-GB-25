<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Focus Stakes ‚Äî Timer + Roulette</title>
  <style>
    .spotify-widget {
    position: fixed;
    top: 20px;
    right: 30px;
    z-index: 10;
    }
    :root {
      --bg: #0f1221;
      --panel: #171b2f;
      --accent: #8b5cf6;
      --accent-2: #22d3ee;
      --text: #e8eaf6;
      --muted: #a5acc7;
      --danger: #ef4444;
      --success: #22c55e;
      --warning: #f59e0b;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius: 16px;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0; padding: 24px; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
      color: var(--text); background: radial-gradient(1200px 800px at 20% -10%, #1b2150, var(--bg));
    }
    h1, h2, h3 { margin: 0 0 8px; }
    .app {
      max-width: 1100px; margin: 0 auto; display: grid; gap: 20px;
      grid-template-columns: 1.1fr .9fr;
    }
    .card {
      background: linear-gradient(180deg, #1a1f39, var(--panel));
      border: 1px solid rgba(255,255,255,.06);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 18px;
    }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    .stack { display: grid; gap: 10px; }
    label { font-size: 12px; color: var(--muted); }
    input, textarea, select {
      width: 100%; background: #0e1327; color: var(--text); border: 1px solid rgba(255,255,255,.08);
      border-radius: 12px; padding: 10px 12px; outline: none; transition: border .2s;
    }
    textarea { min-height: 92px; resize: vertical; }
    input:focus, textarea:focus { border-color: #5b8cff; }
    button {
      background: linear-gradient(90deg, var(--accent), var(--accent-2));
      color: #0b1026; border: none; border-radius: 12px; padding: 10px 14px; font-weight: 700; cursor: pointer;
      filter: drop-shadow(0 6px 12px rgba(34, 211, 238, .15));
    }
    button.secondary { background: transparent; color: var(--text); border: 1px solid rgba(255,255,255,.12); }
    button.ghost { background: transparent; color: var(--muted); border: none; }
    button.danger { background: #2d0f16; color: #ffd9df; border: 1px solid rgba(239, 68, 68, .6); }
    button.success { background: #0d2315; color: #d4ffe4; border: 1px solid rgba(34, 197, 94, .6); }
    .balance {
      display: flex; align-items: center; justify-content: space-between; gap: 16px; padding: 12px 14px; border-radius: 14px;
      background: #0b1026; border: 1px solid rgba(255,255,255,.06);
    }
    .kpi { display:flex; gap:14px; align-items:center; }
    .kpi div { font-size:12px; color: var(--muted); }
    .big { font-size: 30px; font-weight: 800; letter-spacing: .3px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    .timer {
      display:flex; align-items:center; justify-content:center; gap:12px; padding: 14px; border-radius: 14px;
      background: #0c142b; border: 1px solid rgba(255,255,255,.06);
    }
    .pill { padding: 6px 10px; border-radius: 999px; background:#10183a; border:1px solid rgba(255,255,255,.08); font-size:12px; color: var(--muted); }
    canvas { width: 100%; height: auto; max-width: 420px; display:block; margin: 0 auto; }
    .log { max-height: 220px; overflow:auto; padding-right:4px; }
    .log p { margin: 6px 0; font-size: 13px; color: #cfd3ee; }
    .muted { color: var(--muted); font-size: 12px; }
    .footer { text-align:center; color: var(--muted); font-size: 12px; margin-top: 8px; }
    @media (max-width: 920px) {
      .app { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
    <!-- Spotify Widget -->
    <div class="spotify-widget">
    <iframe 
        src="https://open.spotify.com/embed/playlist/37i9dQZF1DXcBWIGoYBM5M" 
        width="300" 
        height="80" 
        frameborder="0" 
        allowtransparency="true" 
        allow="encrypted-media">
    </iframe>
    </div>
  <div class="app">
    <!-- LEFT: Timer + Staking -->
    <section class="card stack">
      <h1>‚è≥ Focus Stakes</h1>
      <div class="balance">
        <div class="kpi">
          <div>
            <div class="muted">Balance</div>
            <div class="big mono" id="balance">‚Äî</div>
          </div>
          <div>
            <div class="muted">Multiplier</div>
            <div class="mono" id="multiplier">1.5√ó</div>
          </div>
        </div>
        <div class="kpi">
          <button class="secondary" id="resetBalanceBtn">Reset Balance</button>
        </div>
      </div>

      <div class="row">
        <div class="stack">
          <label for="taskName">Task name</label>
          <input id="taskName" placeholder="e.g., Draft the report" />
        </div>
        <div class="stack">
          <label for="duration">Duration (minutes)</label>
          <input id="duration" type="number" min="1" value="30" />
        </div>
      </div>

      <div class="row">
        <div class="stack">
          <label for="stake">Stake coins</label>
          <input id="stake" type="number" min="1" value="10" />
        </div>
        <div class="stack">
          <label>&nbsp;</label>
          <button id="startBtn">Start Task</button>
        </div>
      </div>

      <div class="timer">
        <span class="pill">Active Task</span>
        <div class="mono big" id="countdown">00:00:00</div>
        <span class="pill" id="activeTaskLabel">‚Äî</span>
      </div>

      <div class="row">
        <button class="success" id="completeBtn" disabled>Mark Complete</button>
        <button class="danger" id="failBtn" disabled>Give Up / Fail</button>
      </div>

      <div class="card stack" style="background:#12162c;">
        <h3>Activity</h3>
        <div class="log" id="log"></div>
      </div>
    </section>

    <!-- RIGHT: Roulette + Tasks -->
    <section class="card stack">
      <h2>üé° Task Roulette</h2>
      <p class="muted">Enter tasks (one per line). Spin to pick a random task. This does <b>not</b> change your balance.</p>

      <textarea id="rouletteInput" placeholder="Write outline\nClean inbox\nStudy calculus\nWorkout plan"></textarea>
      <div class="row">
        <button id="spinBtn">Spin</button>
        <button class="secondary" id="saveListBtn">Save List</button>
      </div>

      <div style="display:grid; place-items:center; position:relative;">
        <canvas id="wheel" width="500" height="500" aria-label="Roulette wheel"></canvas>
        <div style="position:absolute; top:8px; left:50%; transform:translateX(-50%);">
          <div class="pill">‚ñº</div>
        </div>
      </div>
      <div class="stack">
        <label>Chosen Task</label>
        <input id="chosenTask" readonly />
        <button class="ghost" id="sendToTask">Use for Active Task</button>
      </div>

      <div class="footer">Built for focus. Coins are fictional and stored locally.</div>
    </section>
  </div>

  <script>
    // -----------------------
    // Configuration constants
    // -----------------------
    const DEFAULT_COINS = 100;
    const REWARD_MULTIPLIER = 1.5; // Total payout = stake * multiplier (stake is not separately returned)
    const TICK_MS = 200;           // Update cadence for countdown & wheel animation

    // -----------------------
    // State & persistence
    // -----------------------
    const store = {
      get coins() { return parseInt(localStorage.getItem('coins') || DEFAULT_COINS); },
      set coins(v) { localStorage.setItem('coins', String(v)); renderBalance(); },
      get activeTask() { return JSON.parse(localStorage.getItem('activeTask') || 'null'); },
      set activeTask(obj) { obj ? localStorage.setItem('activeTask', JSON.stringify(obj)) : localStorage.removeItem('activeTask'); },
      get rouletteList() { return JSON.parse(localStorage.getItem('rouletteList') || '[]'); },
      set rouletteList(arr) { localStorage.setItem('rouletteList', JSON.stringify(arr)); },
      pushLog(line) {
        const now = new Date();
        const stamp = now.toLocaleTimeString();
        const p = document.createElement('p');
        p.textContent = `[${stamp}] ${line}`;
        logEl.prepend(p);
      }
    };

    // -----------------------
    // DOM helpers
    // -----------------------
    const $ = s => document.querySelector(s);
    const balanceEl = $('#balance');
    const multiplierEl = $('#multiplier');
    const logEl = $('#log');
    const countdownEl = $('#countdown');
    const activeTaskLabel = $('#activeTaskLabel');
    const taskNameEl = $('#taskName');
    const durationEl = $('#duration');
    const stakeEl = $('#stake');
    const startBtn = $('#startBtn');
    const completeBtn = $('#completeBtn');
    const failBtn = $('#failBtn');
    const resetBalanceBtn = $('#resetBalanceBtn');

    // Roulette DOM
    const rouletteInputEl = $('#rouletteInput');
    const spinBtn = $('#spinBtn');
    const saveListBtn = $('#saveListBtn');
    const wheelCanvas = $('#wheel');
    const chosenTaskEl = $('#chosenTask');
    const sendToTaskBtn = $('#sendToTask');

    // Render balance and multiplier
    function renderBalance() {
      balanceEl.textContent = `${store.coins} coins`;
      multiplierEl.textContent = `${REWARD_MULTIPLIER.toFixed(2)}√ó`;
    }

    // -----------------------
    // Timer logic
    // -----------------------
    let tickHandle = null;

    function startTask() {
      const name = taskNameEl.value.trim();
      const minutes = Math.max(1, parseInt(durationEl.value || '0'));
      const stake = Math.max(1, parseInt(stakeEl.value || '0'));

      if (!name) return alert('Please enter a task name.');
      if (stake > store.coins) return alert('Not enough coins to stake.');

      const now = Date.now();
      const endAt = now + minutes * 60 * 1000;

      // Deduct stake immediately (loss on fail is realized now)
      store.coins = store.coins - stake;

      const task = { name, stake, endAt, startedAt: now, status: 'running' };
      store.activeTask = task;
      store.pushLog(`Task started: "${name}" | Stake: ${stake} | Duration: ${minutes}m`);
      updateControls();
    }

    function markSuccess() {
      const t = store.activeTask; if (!t) return;
      if (Date.now() > t.endAt) return alert('Time is up. Cannot mark success.');

      const payout = Math.floor(t.stake * REWARD_MULTIPLIER);
      store.coins = store.coins + payout; // stake was already deducted at start
      store.pushLog(`‚úÖ Success: "${t.name}" | Payout: +${payout} (multiplier ${REWARD_MULTIPLIER}√ó)`);
      store.activeTask = null;
      updateControls();
    }

    function markFail(reason = 'Failed / time up') {
      const t = store.activeTask; if (!t) return;
      store.pushLog(`‚ùå ${reason}: "${t.name}" | Lost stake: ${t.stake}`);
      store.activeTask = null;
      updateControls();
    }

    function msToHMS(ms) {
      if (ms < 0) ms = 0;
      const s = Math.floor(ms / 1000);
      const h = Math.floor(s / 3600);
      const m = Math.floor((s % 3600) / 60);
      const ss = s % 60;
      const pad = n => String(n).padStart(2, '0');
      return `${pad(h)}:${pad(m)}:${pad(ss)}`;
    }

    function tick() {
      const t = store.activeTask;
      if (!t) {
        countdownEl.textContent = '00:00:00';
        activeTaskLabel.textContent = '‚Äî';
        completeBtn.disabled = true;
        failBtn.disabled = true;
        return;
      }
      const now = Date.now();
      const remaining = t.endAt - now;
      countdownEl.textContent = msToHMS(remaining);
      activeTaskLabel.textContent = t.name;
      completeBtn.disabled = remaining <= 0;
      failBtn.disabled = false;
      if (remaining <= 0) {
        // Auto-fail exactly once when time crosses 0
        markFail('Time up');
      }
    }

    function updateControls() {
      renderBalance();
      // Start or stop ticking based on active task state
      if (store.activeTask && !tickHandle) {
        tickHandle = setInterval(tick, TICK_MS);
      }
      if (!store.activeTask && tickHandle) {
        clearInterval(tickHandle); tickHandle = null; tick();
      }
      // Immediately update once
      tick();
    }

    // -----------------------
    // Roulette wheel logic
    // -----------------------
    const ctx = wheelCanvas.getContext('2d');
    let wheelAngle = 0;      // current rotation (radians)
    let spinning = false;    // is wheel spinning

    function parseTaskLines(text) {
      return text.split(/\n|,/).map(s => s.trim()).filter(Boolean);
    }

    function saveRouletteList() {
      const list = parseTaskLines(rouletteInputEl.value);
      if (list.length === 0) return alert('Enter at least one task for the roulette.');
      store.rouletteList = list;
      drawWheel();
      store.pushLog(`Roulette list saved (${list.length} items).`);
    }

    function loadRouletteList() {
      const list = store.rouletteList;
      rouletteInputEl.value = list.join('\n');
      drawWheel();
    }

    function drawWheel() {
      const tasks = store.rouletteList.length ? store.rouletteList : ['Add tasks ‚Üí'];
      const n = tasks.length;
      const r = wheelCanvas.width / 2;
      ctx.clearRect(0, 0, wheelCanvas.width, wheelCanvas.height);
      ctx.save();
      ctx.translate(r, r);
      ctx.rotate(wheelAngle);

      for (let i = 0; i < n; i++) {
        const start = (i * 2 * Math.PI) / n;
        const end = ((i + 1) * 2 * Math.PI) / n;
        // alternating colors
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.arc(0, 0, r - 6, start, end);
        const hue = (i * 360 / n);
        ctx.fillStyle = `hsl(${hue}, 70%, ${i % 2 ? 45 : 35}%)`;
        ctx.fill();
        ctx.closePath();

        // Text
        ctx.save();
        ctx.fillStyle = '#fff';
        ctx.rotate(start + (end - start) / 2);
        ctx.textAlign = 'right';
        ctx.font = '16px sans-serif';
        ctx.fillText(tasks[i], r - 16, 6);
        ctx.restore();
      }

      // Center hub
      ctx.beginPath();
      ctx.arc(0, 0, 36, 0, 2 * Math.PI);
      ctx.fillStyle = '#0b1026';
      ctx.fill();
      ctx.lineWidth = 2;
      ctx.strokeStyle = 'rgba(255,255,255,.2)';
      ctx.stroke();

      ctx.restore();
    }

    function spinWheel() {
      const list = store.rouletteList;
      if (!list.length) return alert('Add tasks to roulette first.');
      if (spinning) return;

      spinning = true;
      const spins = 4 + Math.random() * 2; // total spins (4‚Äì6)
      const duration = 2500 + Math.random() * 1200; // ms
      const start = performance.now();
      const startAngle = wheelAngle;
      const targetAngle = startAngle + spins * 2 * Math.PI + Math.random() * (Math.PI * 2 / list.length);

      function easeOutCubic(t){ return 1 - Math.pow(1 - t, 3); }

      function frame(now){
        const t = Math.min(1, (now - start) / duration);
        wheelAngle = startAngle + (targetAngle - startAngle) * easeOutCubic(t);
        drawWheel();
        if (t < 1) requestAnimationFrame(frame); else {
          spinning = false;
          announceWheelResult();
        }
      }
      requestAnimationFrame(frame);
    }

    function announceWheelResult(){
      const list = store.rouletteList;
      const n = list.length;
      const rAngle = (2 * Math.PI - (wheelAngle % (2 * Math.PI))) % (2 * Math.PI); // pointer at top (0 rad)
      const sectorAngle = (2 * Math.PI) / n;
      const index = Math.floor(rAngle / sectorAngle) % n;
      const picked = list[index];
      chosenTaskEl.value = picked;
      store.pushLog(`üé° Roulette picked: "${picked}"`);
    }

    // -----------------------
    // Event wiring
    // -----------------------
    startBtn.addEventListener('click', startTask);
    completeBtn.addEventListener('click', markSuccess);
    failBtn.addEventListener('click', () => markFail('Failed'));
    resetBalanceBtn.addEventListener('click', () => {
      if (confirm('Reset balance to default?')) { store.coins = DEFAULT_COINS; store.pushLog('Balance reset.'); }
    });

    saveListBtn.addEventListener('click', saveRouletteList);
    spinBtn.addEventListener('click', spinWheel);
    sendToTaskBtn.addEventListener('click', () => { taskNameEl.value = chosenTaskEl.value || taskNameEl.value; });

    // -----------------------
    // Boot
    // -----------------------
    (function init(){
      renderBalance();
      loadRouletteList();
      updateControls();
      drawWheel();
      store.pushLog('Ready.');
    })();
  </script>
</body>
</html>